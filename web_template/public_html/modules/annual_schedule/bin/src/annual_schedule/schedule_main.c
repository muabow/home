#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <signal.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>
#include <libxml/xmlmemory.h>
#include <libxml/parser.h>
#include <libxml/xpath.h>
#include <libxml/tree.h>

#include <poll.h>
#include <errno.h>
#include <sys/inotify.h>

/*
 *  comment out this line not to save logs
 */
#define SAVE_LOG_FILE
/*
 * uncomment this line to simulate on Linux PC
 */
//#define LINUX_DESKTOP
#ifdef LINUX_DESKTOP
#define INOTIFY_PATH 	"/home/gauss/proj/interm/format"
#else
/* Linux Kernel monitors this folder to check the files under it are modified or not.
 * The files to be monitored are
 *      info_schedule.xml
 *      info_holiday.xml
 */
#define INOTIFY_PATH 	"/opt/interm/public_html/modules/annual_schedule/html/params/newSchedule"
#define TTS_BIN_PATH    "/opt/interm/tts/ttskorplay.sh"
#endif
/*
 * Location of media files are saved.
 */
#define MEDIAFILE_PATH	"/opt/interm/public_html/modules/annual_schedule/html/data/files/"

#define INOTIFY_SCHEDULE_FILE	"info_schedule.xml"
#define INOTIFY_HOLIDAY_FILE	"info_holiday.xml"

#ifdef LINUX_DESKTOP
static const char* sch_path = "/home/gauss/proj/interm/format/info_schedule.xml";
#else
/* Instead of the following variable,
 * it's better to use the combination of INOTIFY_PATH and INOTIFY_SCHEDULE_FILE.
 */
static const char* sch_path = "/opt/interm/public_html/modules/annual_schedule/html/params/newSchedule/info_schedule.xml";
#endif
#ifdef LINUX_DESKTOP
static const char* hol_path = "/home/gauss/proj/interm/format/info_holiday.xml";
#else
/* Instead of the following variable,
 * it's better to use the combination of INOTIFY_PATH and INOTIFY_HOLIDAY_FILE.
 */
static const char* hol_path = "/opt/interm/public_html/modules/annual_schedule/html/params/newSchedule/info_holiday.xml";
#endif

/*
 * If SIGTERM signal is generated,
 * this variable is changed into false to stop all threads.
 */
static bool g_bProcessRunning = true;

/*
 * mutex variable to make sync of three threads.
 */
static pthread_mutex_t g_mutex_lock;

#ifdef LINUX_DESKTOP
#define SCHEDULE_LOG_FILE	"/home/gauss/proj/interm/dev/schedule_prc/schedule.log"
#define HOLIDAY_LOG_FILE	"/home/gauss/proj/interm/dev/schedule_prc/holiday.log"
#define SCHEDULE_CHECK_LOG_FILE	"/home/gauss/proj/interm/dev/schedule_prc/schedule_check.log"
#define SCHEDULE_PLAY_LOG_FILE	"/home/gauss/proj/interm/dev/schedule_prc/schedule_play.log"
#define INFO_LOG_FILE	"/home/gauss/proj/interm/dev/schedule_prc/info.log"
#else
/*
 * log file to save the scheduled info generated by threadReadSchedules using info_schedule.xml
 */
#define SCHEDULE_LOG_FILE	"/opt/interm/public_html/modules/annual_schedule/log/schedule.log"
/*
 * log file to save the holiday info generated by threadReadSchedules using info_holiday.xml
 */
#define HOLIDAY_LOG_FILE	"/opt/interm/public_html/modules/annual_schedule/log/holiday.log"
/*
 * log file to save the holiday info generated by threadCheckSchedule
 */
#define SCHEDULE_CHECK_LOG_FILE	"/opt/interm/public_html/modules/annual_schedule/log/schedule_check.log"
/*
 * log file to save the holiday info generated by threadPlayMedia
 */
#define SCHEDULE_PLAY_LOG_FILE	"/opt/interm/public_html/modules/annual_schedule/log/schedule_play.log"
/*
 * general runtime log
 */
#define INFO_LOG_FILE	"/opt/interm/public_html/modules/annual_schedule/log/info.log"
#endif

/*
 * log file Pointers.
 */
static FILE *g_file_schedule = NULL;
static FILE *g_file_holiday = NULL;
static FILE *g_file_check = NULL;
static FILE *g_file_play = NULL;
static FILE *g_file_info = NULL;

#define MEDIA_FILE_NAME_MAX_LENGTH	   256 // max length of media file name
#define MEDIA_FILE_MAX_NUMBER		      25      // per schedule
#define DAILY_SCHEDULE_MAX_NUMBER		50  // per day
#define WEEKLY_SCHEDULE_MAX_NUMBER		50  // per weekday
#define MONTHLY_SCHEDULE_MAX_NUMBER		50  // per month day
#define YEARLY_SCHEDULE_MAX_NUMBER		200  //  for fast searching of yearly schedule
#define EXCLUDING_DATE_MAX_NUMBER		52  // per repeat
#define HOLIDAY_MAX_NUMBER			      100

typedef char MFILENAME[MEDIA_FILE_NAME_MAX_LENGTH];

/*
 * The following data are set by threadCheckSchedule thread
 * and used by playing thread, threadPlayMedia
 */
static int g_nRepeatPlayCount = -1;
static int g_nMediaFileCount = -1;
static MFILENAME g_sMediaFileList[MEDIA_FILE_MAX_NUMBER];

/*
 * The following data are set by threadCheckSchedule thread
 * and used by the same thread to stop playing
 */
static short g_nDayOfYear_end = 0; // day of year to stop playing
static char g_nHour_end = 0; // hour to stop playing
static char g_nMinute_end = 0; // minute to stop playing
static unsigned char g_nActionType = -1;   // 0 - mp3  1 - script 2 -tts

/*
 * need to check whether already started playing or not.
 * because schedule is minute-based.
 * the following data are used for such purpose.
 */
static short g_nYear_start_playing = -1; // year started playing
static char g_nMonth_start_playing = -1; // month started playing
static char g_nDay_start_playing = -1; // day started playing
static char g_nHour_start_playing = -1; // hour started playing
static char g_nMinute_start_playing = -1; // minute started playing

/*
 * base data structure of schedule
 */
typedef struct _SCHEDULE_BASE {
    /* to discrimate daily or yearly schedule.
     * zero means yearly schedule
     */
    unsigned short working_year;
    unsigned short start_day_of_year; // start day of year (0 ~ 365)
    unsigned short end_day_of_year; // end day of year (0 ~ 365)
    unsigned char end_day_of_month; // end day of month (0 ~ 30)
    unsigned char end_day_of_week; // end day of week (0 ~ 6)
    unsigned char start_hour; // start hour (0 ~ 23)
    unsigned char end_hour; // end hour (0 ~ 23)
    unsigned char start_minute; // start minute (0 ~ 59)
    unsigned char end_minute; // end minute (0 ~ 59)
    unsigned char file_count; // number of media files to play
    unsigned short excluding_date_count; // excluding dates in case of repeat option
    MFILENAME mFileName[MEDIA_FILE_MAX_NUMBER]; // media file names to play
    unsigned short excluding_date[EXCLUDING_DATE_MAX_NUMBER]; // notation of day of year, i.e., 0 ~ 365
    unsigned short repeat_count; // repeat number to play media files
    bool bWeekDaySelected; // whether week day check is selected or not
    int nWeekDaySelected; // week days checked
    unsigned char action_type;
}SCHEDULE_BASE;

/* daily schedule */
typedef struct _DAILY_SCHEDULE_BASE {
    short schedule_number; // 0 ~ DAILY_SCHEDULE_MAX_NUMBER
	SCHEDULE_BASE schedule[DAILY_SCHEDULE_MAX_NUMBER];
}DAILY_SCHEDULE_BASE;

/* weekly schedule */
typedef struct _WEEKLY_SCHEDULE_BASE {
    short schedule_number; // 0 ~ WEEKLY_SCHEDULE_MAX_NUMBER
	SCHEDULE_BASE schedule[WEEKLY_SCHEDULE_MAX_NUMBER];
}WEEKLY_SCHEDULE_BASE;

/* monthly schedule */
typedef struct _MONTHLY_SCHEDULE_BASE {
    short schedule_number; // 0 ~ MONTHLY_SCHEDULE_MAX_NUMBER
	SCHEDULE_BASE schedule[MONTHLY_SCHEDULE_MAX_NUMBER];
}MONTHLY_SCHEDULE_BASE;

/*
 * base data structure of holiday
 */
typedef struct _HOLIDAY_BASE {
    unsigned int start_total_minute_time; // start_day_of_year * 24 * 60 + start_hour * 60 + start_minute
    unsigned int end_total_minute_time; // end_day_of_year * 24 * 60 + end_hour * 60 + end_minute
    char start_month; // start month
    char end_month; // end month
    char start_day; // start day
    char end_day; // end day
    char start_hour; // start hour
    char end_hour; // end hour
    char start_minute; // start minute
    char end_minute; // end minute
}HOLIDAY_BASE;

typedef struct _HOLIDAY {
    bool leap_year; // true if leap year is when holiday data is updated.
    short holiday_number; // 0 ~ HOLIDAY_MAX_NUMBER
    HOLIDAY_BASE holiday[HOLIDAY_MAX_NUMBER];
}HOLIDAY;

typedef struct _YEARLY_SCHEDULE_BASE {
    bool leap_year; // true if leap year is when yearly shedule is updated.
    /*
     * to get into checking daily schedule very quickly
     * because real data of yearly schedule exist on daily schedule data
     */
    unsigned short day_of_year;
}YEARLY_SCHEDULE_BASE;

typedef struct _YEARLY_SCHEDULE_DATE {
    short schedule_number; // 0 ~ YEARLY_SCHEDULE_MAX_NUMBER
    YEARLY_SCHEDULE_BASE schedule[YEARLY_SCHEDULE_MAX_NUMBER];
}YEARLY_SCHEDULE_DATE;

static DAILY_SCHEDULE_BASE g_daily_schedule[366]; // daily schedule data, considering leap year
static WEEKLY_SCHEDULE_BASE g_weekly_schedule[7]; // weekly schedule data
static MONTHLY_SCHEDULE_BASE g_monthly_schedule[31]; // monthly schedule data
static HOLIDAY g_holiday; // holiday data

/* this is only for fast yearly schedule searching.
 * real data is in g_daily_schedule with the value of 0 for working_year
 */
static YEARLY_SCHEDULE_DATE g_yearly_schedule;


/*
 * invoked as SIGTERM is generated
 */
static void *stopProcess(int _parm)
{
    fprintf(g_file_info, "Stopping the process ------------------- !!\n");
    fflush(g_file_info);
    g_bProcessRunning = false;
}


/*
 * open or close log file
 * 	i : 1 ~ 4
 *      1 : schedule log
 *      2 : holiday log
 *      3 : schedule check log
 *      4 : play log
 *  bOpen : true or false
 */
bool logFileHandler(int i, bool bOpen)
{
    bool bRet = false;
#ifdef SAVE_LOG_FILE
    if(i == 1) { // schedule log
        if(bOpen == true) {
            if(g_file_schedule == NULL) {
                g_file_schedule = fopen(SCHEDULE_LOG_FILE, "w+");
                if(g_file_schedule == NULL) {
                    fprintf(g_file_info, "log file open error:%s\n", SCHEDULE_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }else {
                    bRet = true;
                }
            }else {
                bRet = true;
            }
        }else {
            if(g_file_schedule != NULL) {
                fflush(g_file_schedule);
                if(fclose(g_file_schedule) == 0) {
                    g_file_schedule = NULL;
                    bRet = true;
                }else {
                    fprintf(g_file_info, "log file close error:%s\n", SCHEDULE_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }
            }else {
                bRet = true;
            }
        }
    }else if(i == 2) { // holiday log
        if(bOpen == true) {
            if(g_file_holiday == NULL) {
                g_file_holiday = fopen(HOLIDAY_LOG_FILE, "w+");
                if(g_file_holiday == NULL) {
                    fprintf(g_file_info, "log file open error:%s\n", HOLIDAY_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }else {
                    bRet = true;
                }
            }else {
                bRet = true;
            }
        }else {
            if(g_file_holiday != NULL) {
                fflush(g_file_holiday);
                if(fclose(g_file_holiday) == 0) {
                    g_file_holiday = NULL;
                    bRet = true;
                }else {
                    fprintf(g_file_info, "log file close error:%s\n", HOLIDAY_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }
            }else {
                bRet = true;
            }
        }
    }else if(i == 3) { //  schedule check log
         if(bOpen == true) {
            if(g_file_check == NULL) {
                g_file_check = fopen(SCHEDULE_CHECK_LOG_FILE, "w+");
                if(g_file_check == NULL) {
                    fprintf(g_file_info, "log file open error:%s\n", SCHEDULE_CHECK_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }else {
                    bRet = true;
                }
            }else {
                bRet = true;
            }
        }else {
            if(g_file_check != NULL) {
                fflush(g_file_check);
                if(fclose(g_file_check) == 0) {
                    g_file_check = NULL;
                    bRet = true;
                }else {
                    fprintf(g_file_info, "log file close error:%s\n", SCHEDULE_CHECK_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }
            }else {
                bRet = true;
            }
        }
    }else if(i == 4) { // play log
        if(bOpen == true) {
            if(g_file_play == NULL) {
                g_file_play = fopen(SCHEDULE_PLAY_LOG_FILE, "w+");
                if(g_file_play == NULL) {
                    fprintf(g_file_info, "log file open error:%s\n", SCHEDULE_PLAY_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }else {
                    bRet = true;
                }
            }else {
                bRet = true;
            }
        }else {
            if(g_file_play != NULL) {
                fflush(g_file_play);
                if(fclose(g_file_play) == 0) {
                    g_file_play = NULL;
                    bRet = true;
                }else {
                    fprintf(g_file_info, "log file close error:%s\n", SCHEDULE_PLAY_LOG_FILE);
                    fflush(g_file_info);
                    exit(EXIT_FAILURE);
                }
            }else {
                bRet = true;
            }
        }
    }
#endif
    return bRet;
}

/*
 * save each schedule data into the corresponding log file.
 */
void printSchedules()
{
#ifdef SAVE_LOG_FILE
    logFileHandler(1, true);
    fprintf(g_file_schedule, "daily(mem usage:bytes): %d\n", sizeof(g_daily_schedule));
    fprintf(g_file_schedule, "weekly(mem usage:bytes): %d\n", sizeof(g_weekly_schedule));
    fprintf(g_file_schedule, "monthly(mem usage:bytes): %d\n", sizeof(g_monthly_schedule));
    fprintf(g_file_schedule, "yearly searching(mem usage:bytes): %d\n", sizeof(g_yearly_schedule));

	int i,j,k,l;
	for(i = 0; i < 366; ++i) {
        for(j = 0; j < g_daily_schedule[i].schedule_number; ++j) {
            fprintf(g_file_schedule, "daily schedule[%d]\n", i);
            fprintf(g_file_schedule, "   scheduled year[%d]:%d\n", j, g_daily_schedule[i].schedule[j].working_year);
            fprintf(g_file_schedule, "   end day of year[%d]:%d\n", j, g_daily_schedule[i].schedule[j].end_day_of_year);
            fprintf(g_file_schedule, "   start hour[%d]:%d\n", j, g_daily_schedule[i].schedule[j].start_hour);
            fprintf(g_file_schedule, "   end hour[%d]:%d\n", j, g_daily_schedule[i].schedule[j].end_hour);
            fprintf(g_file_schedule, "   start minute[%d]:%d\n", j, g_daily_schedule[i].schedule[j].start_minute);
            fprintf(g_file_schedule, "   end minute[%d]:%d\n", j, g_daily_schedule[i].schedule[j].end_minute);
            fprintf(g_file_schedule, "   repeat count[%d]:%d\n", j, g_daily_schedule[i].schedule[j].repeat_count);
            fprintf(g_file_schedule, "   weekday checkbox selected[%d]:%d\n", j, (int)g_daily_schedule[i].schedule[j].bWeekDaySelected);
            fprintf(g_file_schedule, "   weekday value[%d]:%d\n", j, g_daily_schedule[i].schedule[j].nWeekDaySelected);
            for(k = 0; k < g_daily_schedule[i].schedule[j].file_count; ++k)
                fprintf(g_file_schedule, "   media file[%d]:%s\n", j, g_daily_schedule[i].schedule[j].mFileName[k]);
            for(l = 0; l < g_daily_schedule[i].schedule[j].excluding_date_count; ++l)
                fprintf(g_file_schedule, "   excluding date[%d]:%d\n", j, g_daily_schedule[i].schedule[j].excluding_date[l]);
		}
	}

	for(i = 0; i < 7; ++i) {
        for(j = 0; j < g_weekly_schedule[i].schedule_number; ++j) {
            fprintf(g_file_schedule, "weekly schedule[%d]\n", i);
            fprintf(g_file_schedule, "   end day of week[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].end_day_of_week);
            fprintf(g_file_schedule, "   start hour[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].start_hour);
            fprintf(g_file_schedule, "   end hour[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].end_hour);
            fprintf(g_file_schedule, "   start minute[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].start_minute);
            fprintf(g_file_schedule, "   end minute[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].end_minute);
            fprintf(g_file_schedule, "   repeat count[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].repeat_count);
            for(k = 0; k < g_weekly_schedule[i].schedule[j].file_count; ++k)
                fprintf(g_file_schedule, "   media file[%d]:%s\n", j, g_weekly_schedule[i].schedule[j].mFileName[k]);
            for(l = 0; l < g_weekly_schedule[i].schedule[j].excluding_date_count; ++l)
                fprintf(g_file_schedule, "   excluding date[%d]:%d\n", j, g_weekly_schedule[i].schedule[j].excluding_date[l]);
		}
	}
	for(i = 0; i < 31; ++i) {
        for(j = 0; j < g_monthly_schedule[i].schedule_number; ++j) {
            fprintf(g_file_schedule, "monthly schedule[%d]\n", i);
            fprintf(g_file_schedule, "   end day of month[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].end_day_of_month);
            fprintf(g_file_schedule, "   start hour[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].start_hour);
            fprintf(g_file_schedule, "   end hour[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].end_hour);
            fprintf(g_file_schedule, "   start minute[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].start_minute);
            fprintf(g_file_schedule, "   end minute[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].end_minute);
            fprintf(g_file_schedule, "   repeat count[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].repeat_count);
            fprintf(g_file_schedule, "   weekday checkbox selected[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].bWeekDaySelected);
            fprintf(g_file_schedule, "   weekday value[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].nWeekDaySelected);
            for(k = 0; k < g_monthly_schedule[i].schedule[j].file_count; ++k)
                fprintf(g_file_schedule, "   media file[%d]:%s\n", j, g_monthly_schedule[i].schedule[j].mFileName[k]);
            for(l = 0; l < g_monthly_schedule[i].schedule[j].excluding_date_count; ++l)
                fprintf(g_file_schedule, "   excluding date[%d]:%d\n", j, g_monthly_schedule[i].schedule[j].excluding_date[l]);
		}
    }
    for(i = 0; i < g_yearly_schedule.schedule_number; ++i) {
        fprintf(g_file_schedule, "yearly schedule[%d]\n", i);
        fprintf(g_file_schedule, "   leap year:%d\n", (int)g_yearly_schedule.schedule[i].leap_year);
        fprintf(g_file_schedule, "   day of year in daily schedule:%d\n", (int)g_yearly_schedule.schedule[i].day_of_year);
    }
    logFileHandler(1, false);
#endif
}

/*
 *  save holiday data
 */
void printHolidays()
{
#ifdef SAVE_LOG_FILE
    logFileHandler(2, true);
    fprintf(g_file_holiday, "holiday(mem usage:bytes): %d\n", sizeof(g_holiday));
    int i;
    for(i = 0; i < g_holiday.holiday_number; ++i) {
            fprintf(g_file_holiday, "holidays[%d]\n", i);
            fprintf(g_file_holiday, "   leap year:%d\n", g_holiday.leap_year);
            fprintf(g_file_holiday, "   start total_minutes: %d\n", g_holiday.holiday[i].start_total_minute_time);
            fprintf(g_file_holiday, "   end total_minutes: %d\n", g_holiday.holiday[i].end_total_minute_time);
            fprintf(g_file_holiday, "   start month-day: %d-%d\n", g_holiday.holiday[i].start_month, g_holiday.holiday[i].start_day);
            fprintf(g_file_holiday, "   end month-day: %d-%d\n", g_holiday.holiday[i].end_month, g_holiday.holiday[i].end_day);
            fprintf(g_file_holiday, "   start hour-minute: %d-%d\n", g_holiday.holiday[i].start_hour, g_holiday.holiday[i].start_minute);
            fprintf(g_file_holiday, "   end hour-minute: %d-%d\n", g_holiday.holiday[i].end_hour, g_holiday.holiday[i].end_minute);
    }
    logFileHandler(2, false);
#endif
}

/*
 * set SIGTERM to receive
 */
void initSignalHandler(void)
{
    signal(SIGTERM, (void (*)(int)) stopProcess);
}

/*
 * get week day
 * 	pStr : date info
 *
 * return 0 ~ 6.
 * 0 means SUNDAY.
 */
unsigned char getWeekDay(char *pStr)
{
  struct tm sTm;
  memset((void *) &sTm, 0, sizeof(sTm));
  if (strptime(pStr, "%Y-%m-%d", &sTm) != 0) {
    time_t t = mktime(&sTm);
    if (t >= 0) {
      return (unsigned char)localtime(&t)->tm_wday; // Sunday=0, Monday=1, etc.
    }else {
        fprintf(g_file_info, "getWeekDay error:%s\n", pStr);
        fflush(g_file_info);
        exit(EXIT_FAILURE);
    }
  }else {
    fprintf(g_file_info, "getWeekDay error2:%s\n", pStr);
    fflush(g_file_info);
    exit(EXIT_FAILURE);
  }
}

/*
 * check leap year or not
 * 	nYear : year, such as 2019
 *
 * return trur or false
 */
bool _isLeap(int nYear)
{
	if((nYear % 400 == 0) || ((nYear % 100 != 0) && (nYear % 4 == 0)))
		return true;
	else
		return false;
}

/*
 * get day of year
 * 	_nYear : year, such as 2019
 * 	_nMonth : month, 1 ~ 12
 * 	_nDay : day, 1 ~ 31
 *
 * return day of year (0 ~ 365)
 * bLeap : true or false
 */
int getDayOfYear(int _nYear, int _nMonth, int _nDay, bool *bLeap)
{
	int nMonth[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int nDayOfYear = 0;
    if(_isLeap(_nYear)) {
        nMonth[1] = 29;
        *bLeap = true;
    }else {
        *bLeap = false;
    }
	int i;
	for(i = 0; i < (_nMonth -1); ++i) {
        //printf("%d\n", nMonth[i]);
		nDayOfYear += nMonth[i];
	}
	nDayOfYear += _nDay;
    return (nDayOfYear -1); // starting from 0
}

/*
 * get max days of the month
 * 	_nYear : year, such as 2019
 * 	_nMonth : month, 0 ~ 11
 *
 * return max days
 */
unsigned char getDayOfMonth(int _nYear, int _nMonth)
{
    unsigned char nMonth[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if(_isLeap(_nYear)) {
        nMonth[1] = 29;
    }
    return (nMonth[_nMonth]);
}

/*
 * check excluding date or not
 * 	nExcludingDate_count : the number of excluding dates
 * 	nExcludingDate : excluding dates
 * 	nDay : day to be checked
 *
 * return true or false
 */
bool excludingDay(unsigned short nExcludingDate_count, unsigned short nExcludingDate[EXCLUDING_DATE_MAX_NUMBER], unsigned short nDay)
{
	int i;
	for(i = 0; i < nExcludingDate_count; ++i) {
		if(nDay == nExcludingDate[i])
			return true;
	}
	return false;
}

/*
 * check daily based schedule(daily and yearly schedule) is reached or not
 * 	nYear : year, such as 2019
 *  nDayOfYear : day of year, 0 ~ 365
 * 	nHour : 0 ~ 23
 *  nMinute : 0 ~ 59
 *  nDayOfYear_offset : -1, 0, 1
 * 		-1 : only in case of yearly schedule satisfying the followint condition.
 * 				the current year is leap year but the year set the yearly schedule was not leap year.
 * 		1 :  only in case of yearly schedule satisfying the following condition.
 * 				the current year is not leap year but the year set the yearly schedule was leap year.
 *      0 : daily schedule
 * 				or
 *          yearly schedule satisfying the following condition.
 * 				the current year and the year set the yearly schedule have the same leap year.
 * 	nWeekDay : 0 ~ 6
 *
 * return true or false
 */
bool checkDailyBasedSchedule(int nYear, int nDayOfYear, int nHour, int nMinute, int nDayOfYear_offset, int nWeekDay)
{
    bool bRet = false;
    int i;
    for(i = 0; i < g_daily_schedule[nDayOfYear].schedule_number; ++i) {
        if((g_daily_schedule[nDayOfYear].schedule[i].working_year != 0) // not yearly schedules
                && (g_daily_schedule[nDayOfYear].schedule[i].working_year != nYear)) // old year daily schedule
            continue;

        if(g_daily_schedule[nDayOfYear].schedule[i].bWeekDaySelected == true) { // week day checkbox selected schedule
            if((g_daily_schedule[nDayOfYear].schedule[i].nWeekDaySelected & (1 << nWeekDay)) == 0) // not in week day selected
                continue;
        }

        if((g_daily_schedule[nDayOfYear].schedule[i].start_hour == nHour)
                && (g_daily_schedule[nDayOfYear].schedule[i].start_minute == nMinute)) {
            bRet = true;
            g_nRepeatPlayCount = (int)g_daily_schedule[nDayOfYear].schedule[i].repeat_count;
            if(g_daily_schedule[nDayOfYear].schedule[i].working_year == 0) // yearly schedules
                g_nDayOfYear_end = (short)(g_daily_schedule[nDayOfYear].schedule[i].end_day_of_year - nDayOfYear_offset);
            else
                g_nDayOfYear_end = (short)g_daily_schedule[nDayOfYear].schedule[i].end_day_of_year;
            g_nHour_end = (char)g_daily_schedule[nDayOfYear].schedule[i].end_hour;
            g_nMinute_end = (char)g_daily_schedule[nDayOfYear].schedule[i].end_minute;
            g_nActionType = (unsigned char)g_daily_schedule[nDayOfYear].schedule[i].action_type;
            int j;
            for( j = 0; j < g_daily_schedule[nDayOfYear].schedule[i].file_count; ++j) {
                strcpy(g_sMediaFileList[j], g_daily_schedule[nDayOfYear].schedule[i].mFileName[j]);
            }
            g_nMediaFileCount = j;
            break;
        }
    }
    return bRet;
}

/*
 * check yearly schedule is reached or not
 * 	nYear : year such as 2019
 * 	nDayOfYear : 0 ~ 365
 * 	nHour : 0 ~ 23
 * 	nMinute : 0 ~ 59
 * 	nWeekDay : 0(SUN) ~ 6(SAT)
 *
 * return true or false
 */
bool checkYearlySchedule(int nYear, int nDayOfYear, int nHour, int nMinute, int nWeekDay)
{
    int nOffset = 0;
    bool bRet = false;
    bool bLeapYear = _isLeap(nYear);
    int i;
    for(i = 0; i < g_yearly_schedule.schedule_number; ++i) {
        if(g_yearly_schedule.schedule[i].leap_year != (int)bLeapYear) {
            if(bLeapYear == true) {
                if(nDayOfYear > (31 + 28)) // over march 1
                    nOffset = -1;
            }else {
                if(nDayOfYear > (31 +28)) // over march 1
                    nOffset = 1;
            }
            nDayOfYear = nDayOfYear + nOffset;
            if(g_yearly_schedule.schedule[i].day_of_year == nDayOfYear) {
                bRet = true;
                break;
            }
        }
    }
    if(bRet == true) // otherwise, checked already in checkDailySchedule.
        bRet = checkDailyBasedSchedule(nYear, nDayOfYear, nHour, nMinute, nOffset, nWeekDay);
    return bRet;
}

/*
 * check daily schedule is reached or not
 * 	nYear : year such as 2019
 * 	nDayOfYear : 0 ~ 365
 * 	nHour : 0 ~ 23
 * 	nMinute : 0 ~ 59
 * 	nWeekDay : 0(SUN) ~ 6(SAT)
 *
 * return true or false
 */
bool checkDailySchedule(int nYear, int nDayOfYear, int nHour, int nMinute, int nWeekDay)
{
    bool bRet = false;

    bRet = checkDailyBasedSchedule(nYear, nDayOfYear, nHour, nMinute, 0, nWeekDay);
    return bRet;
}

/*
 * check weekly schedule is reached or not
 * 	nDayOfYear : 0 ~ 365
 * 	nWeekDay : 0(SUN) ~ 6(SAT)
 * 	nHour : 0 ~ 23
 * 	nMinute : 0 ~ 59
 *
 * return true or false
 */
bool checkWeeklySchedule(int nDayOfYear, int nWeekDay, int nHour, int nMinute)
{
    bool bRet = false;

    int i;
    for(i = 0; i < g_weekly_schedule[nWeekDay].schedule_number; ++i) {
        if((g_weekly_schedule[nWeekDay].schedule[i].start_hour == nHour)
                && (g_weekly_schedule[nWeekDay].schedule[i].start_minute == nMinute)) {
            if(excludingDay(g_weekly_schedule[nWeekDay].schedule[i].excluding_date_count,
                            g_weekly_schedule[nWeekDay].schedule[i].excluding_date,
                            (unsigned short)nDayOfYear) == true) // check excluding dates or not
                continue;
            bRet = true;
            g_nRepeatPlayCount = g_weekly_schedule[nWeekDay].schedule[i].repeat_count;
            unsigned char _end_day_of_week = g_weekly_schedule[nWeekDay].schedule[i].end_day_of_week;
            //printf("__checkWeeklySchedule__:%d, %d \n", nDayOfYear, _end_day_of_week);
            if(_end_day_of_week >= nWeekDay) {
                g_nDayOfYear_end = (short)(nDayOfYear + (_end_day_of_week - nWeekDay));
            }else {
                g_nDayOfYear_end = (short)(nDayOfYear + (6 - nWeekDay) + _end_day_of_week + 1);
            }
            g_nHour_end = (char)g_weekly_schedule[nWeekDay].schedule[i].end_hour;
            g_nMinute_end = (char)g_weekly_schedule[nWeekDay].schedule[i].end_minute;
            g_nActionType = (unsigned char)g_weekly_schedule[nWeekDay].schedule[i].action_type;
            //printf("__checkWeeklySchedule__2:%d, %d, %d\n", g_nDayOfYear_end, g_nHour_end, g_nMinute_end);

            int j;
            for( j = 0; j < g_weekly_schedule[nWeekDay].schedule[i].file_count; ++j) {
                strcpy(g_sMediaFileList[j], g_weekly_schedule[nWeekDay].schedule[i].mFileName[j]);
            }
            g_nMediaFileCount = j;
            break;
        }
    }
    return bRet;
}

/*
 * check monthly schedule is reached or not
 * 	nDayOfYear : 0 ~ 365
 * 	nMonthDay : 0 ~ 30
 * 	nHour : 0 ~ 23
 * 	nMinute : 0 ~ 59
 * 	nMonthDay : 0(SUN) ~ 6(SAT)
 *
 * return true or false
 */
bool checkMonthlySchedule(int nDayOfYear, int nMonthDay, int nHour, int nMinute, int nWeekDay)
{
    bool bRet = false;
    //printf("checkMonthlySchedule:%d-%d-%d\n", nMonthDay, nHour, nMinute);
    int i;
    for(i = 0; i < g_monthly_schedule[nMonthDay].schedule_number; ++i) {
        if((g_monthly_schedule[nMonthDay].schedule[i].start_hour == nHour)
                && (g_monthly_schedule[nMonthDay].schedule[i].start_minute == nMinute)) {
            if(excludingDay(g_monthly_schedule[nMonthDay].schedule[i].excluding_date_count,
                            g_monthly_schedule[nMonthDay].schedule[i].excluding_date,
                            (unsigned short)nDayOfYear) == true) // check excluding dates or not
                continue;
            if(g_monthly_schedule[nMonthDay].schedule[i].bWeekDaySelected == true) { // week day checkbox selected schedule
                if((g_monthly_schedule[nMonthDay].schedule[i].nWeekDaySelected & (1 << nWeekDay)) == 0) // not in week day selected
                    continue;
            }

            bRet = true;
            g_nRepeatPlayCount = g_monthly_schedule[nMonthDay].schedule[i].repeat_count;
            g_nDayOfYear_end = (short)(nDayOfYear + g_monthly_schedule[nMonthDay].schedule[i].end_day_of_month - nMonthDay);
            g_nHour_end = (char)g_monthly_schedule[nMonthDay].schedule[i].end_hour;
            g_nMinute_end = (char)g_monthly_schedule[nMonthDay].schedule[i].end_minute;
            g_nActionType = (unsigned char)g_monthly_schedule[nMonthDay].schedule[i].action_type;
            //printf("monthly_schedule:%d-%d-%d\n", g_nDayOfYear_end, g_nHour_end, g_nMinute_end);

            int j;
            for( j = 0; j < g_monthly_schedule[nMonthDay].schedule[i].file_count; ++j) {
                strcpy(g_sMediaFileList[j], g_monthly_schedule[nMonthDay].schedule[i].mFileName[j]);
            }
            g_nMediaFileCount = j;
            break;
        }
    }
    return bRet;
}

/*
 * check holiday or not
 * 	nYear : year such as 2019
 * 	nDayOfYear : 0 ~ 365
 * 	nHour : 0 ~ 23
 * 	nMinute : 0 ~ 59
 *
 * return true or false
 */
bool checkHoliday(int nYear, int nDayOfYear, int nHour, int nMinute)
{
    bool bRet = false;
    bool bLeapYear = _isLeap(nYear);

    if(g_holiday.leap_year != (int)bLeapYear) {
        if(bLeapYear == true) {
            if(nDayOfYear > (31 + 28)) // march 1
                --nDayOfYear;
        }else {
            if(nDayOfYear > (31 + 28)) // March 1
                ++nDayOfYear;
        }
    }

    int i;
    unsigned int nMinuteTime = (unsigned int)nDayOfYear * 24 * 60 + (unsigned int)nHour * 60 + (unsigned int)nMinute;
    for(i = 0; i < g_holiday.holiday_number; ++i) {
        if((nMinuteTime >= g_holiday.holiday[i].start_total_minute_time)
                && (nMinuteTime <= g_holiday.holiday[i].end_total_minute_time)) {
            bRet = true;
            break;
        }
    }
    return bRet;
}

/*
 * update daily schedule data
 * 	bLeapYear : true or false
 * 	nWorking_year : the current year
 * 	nDayOfYear : start day of year(0 ~ 365)
 * 	nDayOfYear_end : end day of year(0 ~ 365)
 * 	nHour_start : start hour(0 ~ 23)
 * 	nHour_end : end hour)0 ~ 23)
 * 	nMinute_start : start minute(0 ~ 59)
 * 	nMinute_end : end minute(0 ~ 59)
 * 	nMediaFileCount : number of media file to play
 * 	mediaFile : media file names to play
 * 	nRepeatCount : repeat count to play
 * 	bWeekDaySelected : week day check box is selected or not(true, false)
 * 	nWeekDaySelected : week day selected with the following data ORed
 * 				1 :  SUNDAY
 * 				2 :  MONDAY
 * 				4 :  TUDESDAY
 * 				8 :  WEDNESDAY
 * 				16 : THURSDAY
 * 				32 : FRIDAY
 * 				64 : SATURDAY
 */
void updateDailySchedule(bool bLeapYear,
            unsigned short nWorking_year,
            unsigned short nDayOfYear,
            unsigned short nDayOfYear_end,
            unsigned char nHour_start,
            unsigned char nHour_end,
            unsigned char nMinute_start,
            unsigned char nMinute_end,
            unsigned char nMediaFileCount,
		    char mediaFile[MEDIA_FILE_MAX_NUMBER][MEDIA_FILE_NAME_MAX_LENGTH],
            unsigned short nRepeatCount,
            bool bWeekDaySelected,
            int nWeekDaySelected,
            unsigned char nAction
			)
{
    int nScheduleNumber = g_daily_schedule[nDayOfYear].schedule_number;
    if(nScheduleNumber >= DAILY_SCHEDULE_MAX_NUMBER) {
        fprintf(g_file_info, "Max updateDailySchedule is reached[%d]:[%d]\n", nDayOfYear, DAILY_SCHEDULE_MAX_NUMBER);
        fflush(g_file_info);
        return;
    }

    if(nWorking_year == 0) {
        if(g_yearly_schedule.schedule_number >= YEARLY_SCHEDULE_MAX_NUMBER) {
            fprintf(g_file_info, "Max yearly schedule searching data reached[%d]:[%d]\n", nDayOfYear, YEARLY_SCHEDULE_MAX_NUMBER);
            return;
        }
    }

    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].working_year = nWorking_year;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].end_day_of_year = nDayOfYear_end;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].start_hour = nHour_start;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].end_hour = nHour_end;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].start_minute = nMinute_start;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].end_minute = nMinute_end;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].bWeekDaySelected = bWeekDaySelected;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].nWeekDaySelected = nWeekDaySelected;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].action_type = nAction;

    int i;
    for(i = 0; i < nMediaFileCount; ++i) {
        strcpy(g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].mFileName[i], &mediaFile[i][0]);
	}
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].file_count = nMediaFileCount;
    g_daily_schedule[nDayOfYear].schedule[nScheduleNumber].repeat_count = nRepeatCount;
    g_daily_schedule[nDayOfYear].schedule_number++;

    if(nWorking_year == 0) {// yearly schedule
        g_yearly_schedule.schedule[g_yearly_schedule.schedule_number].leap_year = bLeapYear;
        g_yearly_schedule.schedule[g_yearly_schedule.schedule_number].day_of_year = nDayOfYear;
        g_yearly_schedule.schedule_number++;
    }
}

/*
 * update weekly schedule data
 * 	nWeekDay : start week day(0 ~ 6)
 * 	nWeekDay_end : end week day(0 ~ 6)
 * 	nHour_start : start hour(0 ~ 23)
 * 	nHour_end : end hour)0 ~ 23)
 * 	nMinute_start : start minute(0 ~ 59)
 * 	nMinute_end : end minute(0 ~ 59)
 * 	nMediaFileCount : number of media file to play
 * 	mediaFile : media file names to play
 * 	nExcludingDate_count : number of excluding dates
 * 	nExcludingDate : excluding dates
 * 	nRepeatCount : repeat count to play
 */
void updateWeeklySchedule(
            unsigned char nWeekDay,
            unsigned char nWeekDay_end,
            unsigned char nHour_start,
            unsigned char nHour_end,
            unsigned char nMinute_start,
            unsigned char nMinute_end,
            unsigned char nMediaFileCount,
		    char mediaFile[MEDIA_FILE_MAX_NUMBER][MEDIA_FILE_NAME_MAX_LENGTH],
            unsigned short nExcludingDate_count,
            unsigned short nExcludingDate[EXCLUDING_DATE_MAX_NUMBER],
            unsigned short nRepeatCount,
            unsigned char nAction
        )
{
    //printf("updateWeeklySchedule:%d\n", nWeekDay);
    int nScheduleNumber = g_weekly_schedule[nWeekDay].schedule_number;
    if(nScheduleNumber >= WEEKLY_SCHEDULE_MAX_NUMBER) {
        fprintf(g_file_info, "Max updateWeeklySchedule is reached[%d]:[%d\n", nWeekDay, WEEKLY_SCHEDULE_MAX_NUMBER);
        fflush(g_file_info);
        return;
    }
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].end_day_of_week = nWeekDay_end;
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].start_hour = nHour_start;
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].end_hour = nHour_end;
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].start_minute = nMinute_start;
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].end_minute = nMinute_end;
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].action_type = nAction;

	int i;
	for(i = 0; i < nMediaFileCount; ++i) {
        strcpy(g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].mFileName[i], &mediaFile[i][0]);
	}
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].file_count = nMediaFileCount;
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].repeat_count = nRepeatCount;
	for(i = 0; i < nExcludingDate_count; ++i) {
        g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].excluding_date[i] = nExcludingDate[i];
	}
    g_weekly_schedule[nWeekDay].schedule[nScheduleNumber].excluding_date_count = nExcludingDate_count;
    g_weekly_schedule[nWeekDay].schedule_number++;
}

/*
 * update monthly schedule data
 * 	nDayOfMonth_start : start month day(0 ~ 30)
 * 	nDayOfMonth_end : end month day(0 ~ 30)
 * 	nHour_start : start hour(0 ~ 23)
 * 	nHour_end : end hour)0 ~ 23)
 * 	nMinute_start : start minute(0 ~ 59)
 * 	nMinute_end : end minute(0 ~ 59)
 * 	nMediaFileCount : number of media file to play
 * 	mediaFile : media file names to play
 * 	nExcludingDate_count : number of excluding dates
 * 	nExcludingDate : excluding dates
 * 	nRepeatCount : repeat count to play
 * 	bWeekDaySelected : week day check box is selected or not(true, false)
 * 	nWeekDaySelected : week day selected with the following data ORed
 * 				1 : SUNDAY
 * 				2 : MONDAY
 * 				4 :	TUDESDAY
 * 				8 : WEDNESDAY
 * 				16 : THURSDAY
 * 				32 : FRIDAY
 * 				64 : SATURDAY
 */
void updateMonthlySchedule(
            unsigned char nDayOfMonth_start,
            unsigned char nDayOfMonth_end,
            unsigned char nHour_start,
            unsigned char nHour_end,
            unsigned char nMinute_start,
            unsigned char nMinute_end,
            unsigned char nMediaFileCount,
		    char mediaFile[MEDIA_FILE_MAX_NUMBER][MEDIA_FILE_NAME_MAX_LENGTH],
            unsigned short nExcludingDate_count,
            unsigned short nExcludingDate[EXCLUDING_DATE_MAX_NUMBER],
            unsigned short nRepeatCount,
            bool bWeekDaySelected,
            int nWeekDaySelected,
            unsigned char nAction
        )
{
    int nScheduleNumber = g_monthly_schedule[nDayOfMonth_start].schedule_number;
    if(nScheduleNumber >= MONTHLY_SCHEDULE_MAX_NUMBER) {
        fprintf(g_file_info, "Max updateMonthlySchedule is reached[%d]:[%d]\n", nDayOfMonth_start, MONTHLY_SCHEDULE_MAX_NUMBER);
        fflush(g_file_info);
        return;
    }
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].end_day_of_month = nDayOfMonth_end;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].start_hour = nHour_start;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].end_hour = nHour_end;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].start_minute = nMinute_start;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].end_minute = nMinute_end;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].bWeekDaySelected = bWeekDaySelected;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].nWeekDaySelected = nWeekDaySelected;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].action_type = nAction;
    int i;
	for(i = 0; i < nMediaFileCount; ++i) {
        strcpy(g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].mFileName[i], &mediaFile[i][0]);
	}
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].file_count = nMediaFileCount;
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].repeat_count = nRepeatCount;
	for(i = 0; i < nExcludingDate_count; ++i) {
        g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].excluding_date[i] = nExcludingDate[i];
	}
    g_monthly_schedule[nDayOfMonth_start].schedule[nScheduleNumber].excluding_date_count = nExcludingDate_count;
    g_monthly_schedule[nDayOfMonth_start].schedule_number++;
}

/*
 * update schedules invoking daily/monthly/yearly schedule update functions.
 * 	bLeapYear : true or false
 * 	nRepeatMode : 0(daily schedule), 1(weekly schedule), 2(monthly schedule)
 * 	nWorking_year : current year
 * 	nDayOfYear_start : start day of year(0 ~ 365)
 * 	nDayOfYear_end : end day of year(0 ~ 365)
 * 	nDayOfMonth_start : start month day(0 ~ 30)
 * 	nDayOfMonth_end : end month day(0 ~ 30)
 * 	nWeekDay_start : start week day(0 ~ 6)
 * 	nWeekDay_end : end week day(0 ~ 6)
 * 	nHour_start : start hour(0 ~ 23)
 * 	nHour_end : end hour)0 ~ 23)
 * 	nMinute_start : start minute(0 ~ 59)
 * 	nMinute_end : end minute(0 ~ 59)
 * 	nRepeatCount : repeat count to play
 *  nRepeatEveryDay : repeat every day radio checkbox selected or not (1 or 0)
 * 	nExcludingDate_count : number of excluding dates
 * 	nExcludingDate : excluding dates
 * 	nMediaFileCount : number of media file to play
 * 	mediaFile : media file names to play
 * 	bWeekDaySelected : week day check box is selected or not(true, false)
 * 	nWeekDaySelected : week day selected with the following data ORed
 * 				1 : SUNDAY
 * 				2 : MONDAY
 * 				4 :	TUDESDAY
 * 				8 : WEDNESDAY
 * 				16 : THURSDAY
 * 				32 : FRIDAY
 * 				64 : SATURDAY
 */
void updateSchedules(bool bLeapYear,
             unsigned char nRepeatMode,
             unsigned short nWorking_year,
             unsigned short nDayOfYear_start,
             unsigned short nDayOfYear_end,
             unsigned char nDayOfMonth_start,
             unsigned char nDayOfMonth_end,
             unsigned char nWeekDay_start,
             unsigned char nWeekDay_end,
             unsigned char nHour_start,
             unsigned char nHour_end,
             unsigned char nMinute_start,
             unsigned char nMinute_end,
             unsigned short nRepeatCount,
             unsigned char nRepeatEveryDay,
             unsigned short nExcludingDate_count,
             unsigned short nExcludingDate[EXCLUDING_DATE_MAX_NUMBER],
             unsigned char nMediaFileCount,
             char mediaFile[MEDIA_FILE_MAX_NUMBER][MEDIA_FILE_NAME_MAX_LENGTH],
             int nWeekDaySelected,
             unsigned char nDayOfMonth_mid_end,
             unsigned char nAction
		    )
{
    if(nRepeatMode == 0) {// daily schedule
        if((nRepeatEveryDay == 1) || (nWeekDaySelected != -1)) {
            unsigned short _dayOfYear;
            bool _bWeekDaySelected = (nWeekDaySelected == -1)?false:true;
			for(_dayOfYear = nDayOfYear_start; _dayOfYear <= nDayOfYear_end; ++_dayOfYear) {
				if(excludingDay(nExcludingDate_count, nExcludingDate, _dayOfYear) == true) {
					continue;
				}else {
               updateDailySchedule(
                  bLeapYear,
                  nWorking_year,
						_dayOfYear,
						nDayOfYear_end,
						nHour_start,
						nHour_end,
						nMinute_start,
						nMinute_end,
						nMediaFileCount,
						mediaFile,
                  nRepeatCount,
                  _bWeekDaySelected,
                  nWeekDaySelected,
                  nAction
					);
				}
			}
		}else {
			updateDailySchedule(
                  bLeapYear,
                  nWorking_year,
                  nDayOfYear_start,
						nDayOfYear_end,
						nHour_start,
						nHour_end,
						nMinute_start,
						nMinute_end,
						nMediaFileCount,
						mediaFile,
                  nRepeatCount,
                  false,
                  nWeekDaySelected,
                  nAction
					);
		}
    }else if(nRepeatMode == 1) { // weekly repeat schedule
        if(nWeekDaySelected != -1) {
            unsigned char _nWeekDay;
            for(_nWeekDay = 0; _nWeekDay < 7; ++_nWeekDay) {
                if((nWeekDaySelected & (1 << _nWeekDay)) != 0) {
                    if((_nWeekDay >= nWeekDay_start) || ((_nWeekDay <= nWeekDay_end))) {
                        updateWeeklySchedule(_nWeekDay,
                                             _nWeekDay,
                                             nHour_start,
                                             nHour_end,
                                             nMinute_start,
                                             nMinute_end,
                                             nMediaFileCount,
                                             mediaFile,
                                             nExcludingDate_count,
                                             nExcludingDate,
                                             nRepeatCount,
                                             nAction
                                             );
                    }
                }
            }
        }else if(nRepeatEveryDay == 1) {
			if(nWeekDay_end >= nWeekDay_start) {
                unsigned char nWeekDay;
				for(nWeekDay = nWeekDay_start; nWeekDay <= nWeekDay_end; ++nWeekDay) {
					updateWeeklySchedule(nWeekDay,
                  nWeekDay,
						nHour_start,
						nHour_end,
						nMinute_start,
						nMinute_end,
						nMediaFileCount,
						mediaFile,
						nExcludingDate_count,
						nExcludingDate,
                  nRepeatCount,
                  nAction
						);

				}
			}else { // ex, wednesday ~ tuesday
                unsigned char nWeekDay;
				for(nWeekDay = nWeekDay_start; nWeekDay <= 6; ++nWeekDay) { // ex, wednesday ~ saturday
					updateWeeklySchedule(nWeekDay,
                  nWeekDay,
						nHour_start,
						nHour_end,
						nMinute_start,
						nMinute_end,
						nMediaFileCount,
						mediaFile,
						nExcludingDate_count,
						nExcludingDate,
                  nRepeatCount,
                  nAction
						);
				}
				for(nWeekDay = 0; nWeekDay <= nWeekDay_end; ++nWeekDay) { // sunday ~ tuesday
					updateWeeklySchedule(nWeekDay,
                  nWeekDay,
						nHour_start,
						nHour_end,
						nMinute_start,
						nMinute_end,
						nMediaFileCount,
						mediaFile,
						nExcludingDate_count,
						nExcludingDate,
                  nRepeatCount,
                  nAction
						);
				}
			}
		}else { // no repeat
			updateWeeklySchedule(nWeekDay_start,
				nWeekDay_end,
				nHour_start,
				nHour_end,
				nMinute_start,
				nMinute_end,
				nMediaFileCount,
				mediaFile,
				nExcludingDate_count,
				nExcludingDate,
            nRepeatCount,
            nAction
				);
		}
    }else if(nRepeatMode == 2) { // monthly repeat schedule
        if((nRepeatEveryDay == 1) || (nWeekDaySelected != -1)) {
            bool _bWeekDaySelected = (nWeekDaySelected == -1)?false:true;
            if(nDayOfMonth_end >= nDayOfMonth_start) {
                unsigned char nDayOfMonth;
                for(nDayOfMonth = nDayOfMonth_start; nDayOfMonth <= nDayOfMonth_end; ++nDayOfMonth) {
                    updateMonthlySchedule(nDayOfMonth,
                                          nDayOfMonth,
                                          nHour_start,
                                          nHour_end,
                                          nMinute_start,
                                          nMinute_end,
                                          nMediaFileCount,
                                          mediaFile,
                                          nExcludingDate_count,
                                          nExcludingDate,
                                          nRepeatCount,
                                          _bWeekDaySelected,
                                          nWeekDaySelected,
                                          nAction
                                          );
                }
            }else {
                unsigned char nDayOfMonth;
                for(nDayOfMonth = nDayOfMonth_start; nDayOfMonth <= nDayOfMonth_mid_end; ++nDayOfMonth) {
                    updateMonthlySchedule(nDayOfMonth,
                                          nDayOfMonth,
                                          nHour_start,
                                          nHour_end,
                                          nMinute_start,
                                          nMinute_end,
                                          nMediaFileCount,
                                          mediaFile,
                                          nExcludingDate_count,
                                          nExcludingDate,
                                          nRepeatCount,
                                          _bWeekDaySelected,
                                          nWeekDaySelected,
                                          nAction
                                          );
                }
                for(nDayOfMonth = 0; nDayOfMonth <= nDayOfMonth_end; ++nDayOfMonth) {
                    updateMonthlySchedule(nDayOfMonth,
                                          nDayOfMonth,
                                          nHour_start,
                                          nHour_end,
                                          nMinute_start,
                                          nMinute_end,
                                          nMediaFileCount,
                                          mediaFile,
                                          nExcludingDate_count,
                                          nExcludingDate,
                                          nRepeatCount,
                                          _bWeekDaySelected,
                                          nWeekDaySelected,
                                          nAction
                                          );
                }
            }
		}else {
			updateMonthlySchedule(nDayOfMonth_start,
							nDayOfMonth_end,
							nHour_start,
							nHour_end,
							nMinute_start,
							nMinute_end,
							nMediaFileCount,
							mediaFile,
							nExcludingDate_count,
							nExcludingDate,
                     nRepeatCount,
                     false,
                     nWeekDaySelected,
                     nAction
						);
		}
	}else if(nRepeatMode == 3) { // yearly repeat schedule
        ;// same as nRepeatMode is 0
	}
}


/*
 * read xml file to parse and update schedule data
 * - at booting time
 * - xml file is changed
 */
void readSchedules()
{
    memset(g_daily_schedule, 0, sizeof(g_daily_schedule));
    memset(g_weekly_schedule, 0, sizeof(g_weekly_schedule));
    memset(g_monthly_schedule, 0, sizeof(g_monthly_schedule));
    memset(&g_yearly_schedule, 0, sizeof(g_yearly_schedule));

	xmlDoc *doc = xmlParseFile (sch_path);

	xmlXPathContext *xpathCtx = xmlXPathNewContext (doc);
	xmlXPathObject *xpathObj;
    xpathObj = xmlXPathEvalExpression ((xmlChar *) "/interm_schedule/note/schedule", xpathCtx);

    int nIndex;
    for (nIndex = 0; nIndex < xpathObj->nodesetval->nodeNr; ++nIndex)
    {
        xmlNode *sub_node = xpathObj->nodesetval->nodeTab[nIndex];
        xmlNode* cur = sub_node->xmlChildrenNode;

        unsigned short nWorking_year = 0;
        unsigned char nWeekDay_start = 0;
        unsigned short nDayOfYear_start = 0;
        unsigned short nDayOfYear_end = 0;
        unsigned char nHour_start = 0;
        unsigned char nMinute_start = 0;
        unsigned char nWeekDay_end = 0;
        unsigned char nHour_end = 0;
        unsigned char nMinute_end = 0;
        unsigned char nRepeatMode = 0; // 0: no_repeat(i.e., daily) 1: week, 2: month, 3: year
        unsigned short nRepeatCount = 0;
        unsigned char nRepeatEveryDay = 0;
        unsigned short nExcludingDate[EXCLUDING_DATE_MAX_NUMBER] = {0,};
        unsigned short nExcludingDate_count = 0;
        char mediaFile[MEDIA_FILE_MAX_NUMBER][MEDIA_FILE_NAME_MAX_LENGTH];
        unsigned char nMediaFileCount = 0;
        unsigned char nDayOfMonth_start = 0;
        unsigned char nDayOfMonth_mid_end = 0;
        unsigned char nDayOfMonth_end = 0;
        unsigned char nActionType = 0;
        int nWeekDaySelected = -1; // from week day check boxs
        bool bLeapYear = false;

        while (cur != NULL)
        {
            if(!xmlStrcmp(cur->name, (const xmlChar *)"begin_date")) {
                nWeekDay_start =  getWeekDay((char*)cur->children->content);
                //printf("___weekday2:%s, %d\n", cur->children->content, nWeekDay_start);

                char *cPtr = strtok((char*)cur->children->content, "-");
                int _year = atoi(cPtr);
                cPtr = strtok(NULL, "-");
                int _month = atoi(cPtr);
                cPtr = strtok(NULL, "-");
                int _day = atoi(cPtr);
                nWorking_year = (unsigned short)_year;
                nDayOfMonth_start = (unsigned char)(_day -1); // starting from 0
                nDayOfYear_start = (unsigned short)getDayOfYear(_year, _month, _day, &bLeapYear);
                nDayOfMonth_mid_end = getDayOfMonth(_year, _month -1);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"end_date")) {
                nWeekDay_end =  getWeekDay((char*)cur->children->content);
                //printf("end_date: %s, %d\n", (char*)cur->children->content, nWeekDay_end);
                char *cPtr = strtok((char*)cur->children->content, "-");
                int _year = atoi(cPtr);
                cPtr = strtok(NULL, "-");
                int _month = atoi(cPtr);
                cPtr = strtok(NULL, "-");
                int _day = atoi(cPtr);
                nDayOfMonth_end = (unsigned char)(_day -1);
                nDayOfYear_end = (unsigned short)getDayOfYear(_year, _month, _day, &bLeapYear);

            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"begin_h")) {
                nHour_start = (unsigned char)atoi((char*)cur->children->content);
                //printf("___begin_h[%d]:%d\n", nIndex, nHour_start);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"begin_m")) {
                nMinute_start = (unsigned char)atoi((char*)cur->children->content);
                //printf("___begin_m[%d]:%d\n", nIndex, nMinute_start);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"end_h")) {
                nHour_end = (unsigned char)atoi((char*)cur->children->content);
                //printf("___end_h[%d]:%d\n", nIndex, nHour_end);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"end_m")) {
                nMinute_end = (unsigned char)atoi((char*)cur->children->content);
                //printf("___end_m[%d]:%d\n", nIndex, nMinute_end);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"repeat")) { // repeat option
                if(cur->children != NULL) {
                    if(strcmp((char*)cur->children->content, "week") == 0)
                        nRepeatMode = 1;
                    else if(strcmp((char*)cur->children->content, "month") == 0)
                        nRepeatMode = 2;
                    else if(strcmp((char*)cur->children->content, "year") == 0)
                        nRepeatMode = 3;
                }
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"repeat_cnt")) {
                if(cur->children->content != NULL)
                    nRepeatCount = (unsigned short)atoi((char*)cur->children->content);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"action_type")) { // repeat option
                if(cur->children != NULL) {
                    if(strcmp((char*)cur->children->content, "mp3") == 0)
                        nActionType = 0;
                    else if(strcmp((char*)cur->children->content, "script") == 0)
                        nActionType = 1;
                    else if(strcmp((char*)cur->children->content, "tts") == 0)
                        nActionType = 2;
                }
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"contents")) { // media files to play
                //int nCheck = 0;
                if(cur->children != NULL) {
                    char *cPtr = strtok((char*)cur->children->content, "|");

                    if(cPtr != NULL) {
                        while(cPtr != NULL) {
                            //++nCheck;
                            strcpy(&mediaFile[nMediaFileCount++][0], cPtr);
                            //printf("mediaFile__[%d]:%s\n", nCheck, &mediaFile[nMediaFileCount-1][0]);
                            if(nMediaFileCount >= MEDIA_FILE_MAX_NUMBER) {
                                fprintf(g_file_info, "Max Media File is reached:%d\n", MEDIA_FILE_MAX_NUMBER);
                                fflush(g_file_info);
                                break;
                            }
                            cPtr = strtok(NULL, "|");
                        }
                    }else {
                        strcpy(&mediaFile[nMediaFileCount++][0], (char*)cur->children->content);
                    }
                }
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"repeat_everyday")) { // repeat every day or repeat once whole in term
                if(cur->children != NULL) {
                    int _nRepeatEveryDay = atoi((char*)cur->children->content);
                    nRepeatEveryDay = (_nRepeatEveryDay==1)?1:0;
                }
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"excludes")) { // excluding dates from repeat schedules
                xpathCtx->node = cur;
                xmlXPathObject *xpathObj2 = xmlXPathEvalExpression ((xmlChar *) "./start_date", xpathCtx);

                char *cPtr;
                int _year, _month, _day;
                int i;
                for(i = 0; i < xpathObj2->nodesetval->nodeNr; ++i) {
                    xmlNode *sub_node = xpathObj2->nodesetval->nodeTab[i];
                    //printf("__excludes__:%s", (char*)sub_node->children->content);
                    cPtr = strtok((char*)(sub_node->children->content), "-");
                    _year = atoi(cPtr);
                    cPtr = strtok(NULL, "-");
                    _month = atoi(cPtr);
                    cPtr = strtok(NULL, "-");
                    _day = atoi(cPtr);
                    nExcludingDate[nExcludingDate_count++] = (unsigned short)getDayOfYear(_year, _month, _day, &bLeapYear);
                    if(nExcludingDate_count >= EXCLUDING_DATE_MAX_NUMBER) {
                        fprintf(g_file_info, "Max excluding date is reached:%d\n", EXCLUDING_DATE_MAX_NUMBER);
                        fflush(g_file_info);
                        break;
                    }
                }
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"dow")) { // week day checkbox is selected
                if(cur->children != NULL) {
                    char *cPtr = strtok((char*)cur->children->content, ",");
                    nWeekDaySelected = 0;
                    if(cPtr != NULL) {
                        while(cPtr != NULL) {
                            printf("%d\n", (int)atoi(cPtr));
                            nWeekDaySelected |= (1 << (int)atoi(cPtr));
                            cPtr = strtok(NULL, ",");
                        }
                    }else {
                        nWeekDaySelected = (int)atoi((char*)cur->children->content);
                    }
                    printf("tot: %d\n", nWeekDaySelected);
                }
            }

            cur = cur->next;
        }
        if(nRepeatMode == 3) { // yearly schedules
            nRepeatMode = 0; // same as daily schedule
            nWorking_year = 0; // this is different from daily schedule
        }
        // update schedule based on the info such as nRepeatMode, ..., mediaFile.
        updateSchedules(bLeapYear,
                        nRepeatMode,
                        nWorking_year,
                        nDayOfYear_start,
                        nDayOfYear_end,
                        nDayOfMonth_start,
                        nDayOfMonth_end,
                        nWeekDay_start,
                        nWeekDay_end,
                        nHour_start,
                        nHour_end,
                        nMinute_start,
                        nMinute_end,
                        nRepeatCount,
                        nRepeatEveryDay,
                        nExcludingDate_count,
                        nExcludingDate,
                        nMediaFileCount,
                        mediaFile,
                        nWeekDaySelected,
                        nDayOfMonth_mid_end,
                        nActionType
                        );
    }
    xmlXPathFreeContext(xpathCtx);
    xpathCtx = NULL;
    xmlCleanupParser();
    xmlFreeDoc(doc);
    doc = NULL;
    printSchedules(); // just for debugging
}

/*
 * update holiday data
 * 	bLeapYear : true or not
 * 	nDayOfYear_start : start day of year(0 ~ 365)
 * 	nDayOfYear_end : end day of year(0 ~ 365)
 * 	nMonth_start : start month(0 ~ 11)
 * 	nMonth_end : end month(0 ~ 11)
 * 	nDay_start : start day(0 ~ 30)
 * 	nDay_end : start day(0 ~ 30)
 * 	nHour_start : start hour(0 ~ 23)
 * 	nHour_end : end hour(0 ~ 23)
 * 	nMinute_start : start hour(0 ~ 59)
 * 	nMinute_end : end hour(0 ~ 59)
 */
void updateHolidays(
            bool bLeapYear,
            unsigned short nDayOfYear_start,
            unsigned short nDayOfYear_end,
            unsigned char nMonth_start,
            unsigned char nMonth_end,
            unsigned char nDay_start,
            unsigned char nDay_end,
            unsigned char nHour_start,
            unsigned char nHour_end,
            unsigned char nMinute_start,
            unsigned char nMinute_end
            )
{
    g_holiday.leap_year = bLeapYear;
    g_holiday.holiday[g_holiday.holiday_number].start_total_minute_time
            = nDayOfYear_start * 24 * 60 + nHour_start * 60 + nMinute_start;
    g_holiday.holiday[g_holiday.holiday_number].end_total_minute_time
            = nDayOfYear_end * 24 * 60 + nHour_end * 60 + nMinute_end;
    g_holiday.holiday[g_holiday.holiday_number].start_month = (char)nMonth_start;
    g_holiday.holiday[g_holiday.holiday_number].end_month = (char)nMonth_end;
    g_holiday.holiday[g_holiday.holiday_number].start_day = (char)nDay_start;
    g_holiday.holiday[g_holiday.holiday_number].end_day = (char)nDay_end;
    g_holiday.holiday[g_holiday.holiday_number].start_hour = (char)nHour_start;
    g_holiday.holiday[g_holiday.holiday_number].end_hour = (char)nHour_end;
    g_holiday.holiday[g_holiday.holiday_number].start_minute = (char)nMinute_start;
    g_holiday.holiday[g_holiday.holiday_number].end_minute = (char)nMinute_end;
    g_holiday.holiday_number++;
}

/*
 * read xml file to parse and update holiday data
 * - at booting time
 * - xml file is changed
 */
void readHolidays()
{
    memset(&g_holiday, 0, sizeof(g_holiday));

    time_t	current_time;
    struct tm *struct_time;
    time(&current_time);
    struct_time = localtime(&current_time);
    int nYear = struct_time->tm_yday;


	xmlDoc *doc = xmlParseFile (hol_path);
	xmlXPathContext *xpathCtx = xmlXPathNewContext (doc);
	// maxinum
    xmlXPathObject *xpathObj = xmlXPathEvalExpression ((xmlChar *) "/interm_holiday/holiday", xpathCtx);
    int nHoliday = xpathObj->nodesetval->nodeNr;

    if(nHoliday > HOLIDAY_MAX_NUMBER) {
        nHoliday = HOLIDAY_MAX_NUMBER;
        fprintf(g_file_info, "Max Holiday is reached:%d\n", HOLIDAY_MAX_NUMBER);
        fflush(g_file_info);
    }
    int nIndex;
    for (nIndex = 0; nIndex < nHoliday; ++nIndex) {
        xmlNode *sub_node = xpathObj->nodesetval->nodeTab[nIndex];
        xmlNode* cur = sub_node->xmlChildrenNode;

        unsigned short nDayOfYear_start = 0;
        unsigned short nDayOfYear_end = 0;
        unsigned char nMonth_start = 0;
        unsigned char nMonth_end = 0;
        unsigned char nDay_start = 0;
        unsigned char nDay_end = 0;
        unsigned char nHour_start = 0;
        unsigned char nHour_end = 0;
        unsigned char nMinute_start = 0;
        unsigned char nMinute_end = 0;
        bool bLeapYear = false;
        while (cur != NULL) {
            if(!xmlStrcmp(cur->name, (const xmlChar *)"begin_date")) {
                char* pch;
                pch = strtok((char*)cur->children->content, "-");
                nMonth_start = (unsigned char)atoi(pch);
                pch = strtok(NULL,"-");
                nDay_start = (unsigned char)atoi(pch);
                nDayOfYear_start = (unsigned short)getDayOfYear(nYear, nMonth_start, nDay_start, &bLeapYear);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"end_date")) {
                char* pch;
                pch = strtok((char*)cur->children->content, "-");
                nMonth_end = (unsigned char)atoi(pch);
                pch = strtok(NULL, "-");
                nDay_end = (unsigned char)atoi(pch);
                nDayOfYear_end = (unsigned short)getDayOfYear(nYear, nMonth_end, nDay_end, &bLeapYear);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"begin_h")) {
                nHour_start = (unsigned char)atoi((char*)cur->children->content);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"end_h")) {
                nHour_end = (unsigned char)atoi((char*)cur->children->content);
            }else if(!xmlStrcmp(cur->name, (const xmlChar *)"begin_m")) {
                nMinute_start = (unsigned char)atoi((char*)cur->children->content);
            }else if (!xmlStrcmp(cur->name, (const xmlChar *)"end_m")) {
                nMinute_end = (unsigned char)atoi((char*)cur->children->content);
            }
            cur = cur->next;
        }
        updateHolidays(
                    bLeapYear,
                    nDayOfYear_start,
                    nDayOfYear_end,
                    nMonth_start,
                    nMonth_end,
                    nDay_start,
                    nDay_end,
                    nHour_start,
                    nHour_end,
                    nMinute_start,
                    nMinute_end
                    );
    }
	xmlXPathFreeContext(xpathCtx);
	xmlCleanupParser();
	xmlFreeDoc(doc);
    doc = NULL;
    printHolidays(); // just for debugging
}

/*
 * invoke php function to start or stop playing media file
 * 	bPlay : true or false
 *
 * in case of stopping, udpate global variables to default values.
 */
void setAudioCommand(bool bPlay)
{
    if(bPlay) {
      if (g_nActionType == 0){
         char *php_command = "php -q -f /opt/interm/www/html/run_schedule_config.php on";
         system(php_command);
      }
    }else {
      if (g_nActionType == 0){
         char *php_command = "php -q -f /opt/interm/www/html/run_schedule_config.php off";
         system(php_command);
         char *command1 = "su -c 'killall -SIGTERM audio_player'";
         char *command2 = "su -c 'killall -SIGTERM aplay'";
         system(command1);
         system(command2);
      }
        //printf("setAudioCommand__stop playing\n");
        g_nRepeatPlayCount = -1;
        g_nMediaFileCount = -1;
        g_nDayOfYear_end = -1;
        g_nHour_end = -1;
        g_nMinute_end = -1;
        g_nActionType = -1;
        g_nYear_start_playing = -1;
    }
}

/*
 * Reread schedules because xml file is updated
 * 	event : contains xml file name
 */
void reReadSchedules(const struct inotify_event *event)
{
    if(strcmp(INOTIFY_SCHEDULE_FILE, event->name) == 0) {
        pthread_mutex_lock(&g_mutex_lock);
        setAudioCommand(false);
        fprintf(g_file_info, "reexecuting readSchedules\n");
        fflush(g_file_info);
        readSchedules();
        pthread_mutex_unlock(&g_mutex_lock);
    }else if(strcmp(INOTIFY_HOLIDAY_FILE, event->name) == 0) {
        pthread_mutex_lock(&g_mutex_lock);
        setAudioCommand(false);
        //printf("reexecuting readHolidays\n");
        readHolidays();
        pthread_mutex_unlock(&g_mutex_lock);
    }/*else {
        printf("read_schedules...%s\n", event->name);
    }*/
}

/*
 *  thread to monitor xml files and read to update schedule and holiday data
 */
void* threadReadSchedules()
{
    logFileHandler(1, true);

    //time_t	current_time;
    //struct tm *struct_time;

    pthread_mutex_lock(&g_mutex_lock);
    //time(&current_time);
    //struct_time = localtime(&current_time);
    //printf("threadReadSchedules started:%s\n", asctime(struct_time));
    readSchedules();
    readHolidays();
    pthread_mutex_unlock(&g_mutex_lock);

	int ret;
	int fd;
	int wd;
	char buf[4096] __attribute__ ((aligned(__alignof__(struct inotify_event))));
	char *ptr;
	ssize_t size;
	const struct inotify_event *event;

	fd = inotify_init();
	if(fd < 0) {
        fprintf(g_file_info, "inotify_init error:[%s]", strerror(errno));
        fflush(g_file_info);
        exit(EXIT_FAILURE);
	}

	wd = inotify_add_watch(fd, INOTIFY_PATH, IN_MODIFY | IN_CREATE | IN_DELETE);
	if(wd < 0) {
        fprintf(g_file_info, "Failed to add watch [%s] [%s]", INOTIFY_PATH, strerror(errno));
        fflush(g_file_info);
        exit(EXIT_FAILURE);
	}
    fprintf(g_file_info, "--------threadReadSchedules started------\n");
    fflush(g_file_info);
    while(g_bProcessRunning) {
        size = read(fd, buf, sizeof(buf)); // wait
		if((size == -1) && (errno != EAGAIN)) {
            fprintf(g_file_info, "inotify watch read error : %s", strerror(errno));
            fflush(g_file_info);
            exit(EXIT_FAILURE);
		}
		if(size <= 0)
			break;
		for(ptr = buf; ptr < (buf + size); ptr += sizeof(struct inotify_event) + event->len) {
			event = (struct inotify_event *)ptr;
            reReadSchedules(event); // update data
		}
	}
    //printf("----------threadReadSchedules finished----------\n");
    ret = inotify_rm_watch(fd, wd);
	if(ret < 0) {
        fprintf(g_file_info, "inotify watch remove error : %s", strerror(errno));
        fflush(g_file_info);
        exit(EXIT_FAILURE);
	}
    fprintf(g_file_info, "--------threadReadSchedules finished------\n");
    fflush(g_file_info);
}

/*
 * thread to play media files
 *
 * if g_nRepeatPlayCount, which is updated by threadCheckSchedule thread, is greater than zero,
 * starts playing.
 */
void* threadPlayMedia()
{
#ifdef SAVE_LOG_FILE
    logFileHandler(4, true);
#endif
//    bool bStarted = false;
    time_t	current_time;
    struct tm *struct_time;
    fprintf(g_file_info, "--------threadPlayMedia started------\n");
    fflush(g_file_info);
    while(g_bProcessRunning) {
        bool bPlay = false;
        pthread_mutex_lock(&g_mutex_lock);
//        if(bStarted == false) {
//            bStarted = true;
//            printf("----------threadPlayMedia started----------\n");
//        }
        if(g_nRepeatPlayCount > 0)
            bPlay = true;
        pthread_mutex_unlock(&g_mutex_lock);
        if(bPlay == true) {
            int nRepeat;
            for(nRepeat = 0; nRepeat < g_nRepeatPlayCount; ++nRepeat) {
                int nFileCount;
                for(nFileCount = 0; nFileCount < g_nMediaFileCount; ++nFileCount) {
                    time(&current_time);
                    struct_time = localtime(&current_time);
                    char command[1024];
                    char mediaFile[MEDIA_FILE_NAME_MAX_LENGTH + strlen(MEDIAFILE_PATH) + 10];
                    if (g_nActionType == 0){ // mp3 or tts
                       strcat(mediaFile, "\""); // to get around the case that file name contains space
                       strcpy(mediaFile + 1, MEDIAFILE_PATH);
                       strcat(mediaFile, g_sMediaFileList[nFileCount]);
                       strcat(mediaFile, "\""); // to get around the case that file name contains space

                       if(strstr(g_sMediaFileList[nFileCount], "tts") == 0) { // mp3 file
                           sprintf(command, "su -c \'/opt/interm/bin/audio_player %s\'", mediaFile);
   #ifdef SAVE_LOG_FILE
                           fprintf(g_file_play, "audio_player[%s]:%s\n", asctime(struct_time), mediaFile);
                           fflush(g_file_play);
                           //printf("audio_player[%s]:%s\n", asctime(struct_time), mediaFile);
   #endif
                       }else{ // tts wave file
                           sprintf(command, "su -c \'aplay %s\'", mediaFile);
                           fprintf(g_file_play, "aplay[%s]:%s\n", asctime(struct_time), mediaFile);
                           fflush(g_file_play);
                           //printf("aplay[%s]:%s\n", asctime(struct_time), mediaFile);
                       }
                    }
                    else if (g_nActionType == 2){  // tts
                       strcat(mediaFile, g_sMediaFileList[nFileCount]);
                       sprintf(command, "su -c \'%s \"%s\" \'", TTS_BIN_PATH, mediaFile);
                       fprintf(g_file_play, "TTS run[%s]:%s\n", asctime(struct_time), mediaFile);
                       fflush(g_file_play);

                    }
                    else if (g_nActionType == 1){  // script
                       strcat(mediaFile, g_sMediaFileList[nFileCount]);
                       sprintf(command, "su -c \'%s\'", mediaFile);
                       fprintf(g_file_play, "Script run[%s]:%s\n", asctime(struct_time), mediaFile);
                       fflush(g_file_play);
                    }
                    system(command);
                }
            }
        }

        pthread_mutex_lock(&g_mutex_lock);
        g_nRepeatPlayCount = -1;
        g_nMediaFileCount = -1;
        pthread_mutex_unlock(&g_mutex_lock);

        usleep(1000000);
#ifdef SAVE_LOG_FILE
//        time(&current_time);
//        struct_time = localtime(&current_time);
//        fprintf(g_file_play, "threadPlayMedia idle:%s\n", asctime(struct_time));
//        fflush(g_file_play);
#endif
    }
#ifdef SAVE_LOG_FILE
    fprintf(g_file_info, "----------threadPlayMedia finished----------\n");
    fflush(g_file_info);
    logFileHandler(4, false);
#endif
}

/*
 * check playing is on going or not with the data.
 * 	nYear : day of year(0 ~ 365)
 * 	nMonth : 0 ~ 11
 * 	nDay : 0 ~ 30
 * 	nHour : 0 ~ 23
 * 	nMinute : 0 ~ 59
 *
 * return true or false
 */
bool startPlaying(int nYear, int nMonth, int nDay, int nHour, int nMinute)
{
    if(((short)nYear == g_nYear_start_playing)
            && ((char)nMonth == g_nMonth_start_playing)
            && ((char)nDay == g_nDay_start_playing)
            && ((char)nHour == g_nHour_start_playing)) {
        if((char)nMinute == g_nMinute_start_playing) {
            return true;
        }else if((char)nMinute == (g_nMinute_start_playing +1)) { // minute is different
            g_nYear_start_playing = -1; // in order to make it possible to set schedule again
            return false;
        }else {
            return false;
        }
    }else {
        return false;
    }
}

/*
 * check shechedul is coming.
 * and update data to be used in startPlaying
 */
void* threadCheckSchedule(void* Para)
{
#ifdef SAVE_LOG_FILE
    logFileHandler(3, true);
#endif
	time_t	current_time;
	struct tm *struct_time;
    //bool  bFirst = true;
    fprintf(g_file_info, "--------threadCheckSchedule started------\n");
    fflush(g_file_info);
//    bool bStarted = false;
    while(g_bProcessRunning) {
        pthread_mutex_lock(&g_mutex_lock);
//        if(bStarted == false) {
//            bStarted = true;
//            printf("----------threadCheckSchedule started----------\n");
//        }
        time(&current_time);
        struct_time = localtime(&current_time);
        bool bCheck = false;

        if(checkHoliday(struct_time->tm_year+1900, struct_time->tm_yday, struct_time->tm_hour, struct_time->tm_min)) { // holiday
            if(g_nRepeatPlayCount != -1) {
                setAudioCommand(false);
            }
        }else { // not holiday such that can play.
            if((g_nRepeatPlayCount == -1) // now it's not playing. Check to play or not.
                    &&(startPlaying(struct_time->tm_year + 1900, struct_time->tm_mon, struct_time->tm_mday, struct_time->tm_hour, struct_time->tm_min) == false)) { // not playing
                bCheck = checkDailySchedule(struct_time->tm_year + 1900, struct_time->tm_yday, struct_time->tm_hour, struct_time->tm_min, struct_time->tm_wday);
                if(bCheck == false)
                    bCheck = checkWeeklySchedule(struct_time->tm_yday, struct_time->tm_wday, struct_time->tm_hour, struct_time->tm_min);
                if(bCheck == false)
                    bCheck = checkMonthlySchedule(struct_time->tm_yday, struct_time->tm_mday -1, struct_time->tm_hour, struct_time->tm_min, struct_time->tm_wday);
                if(bCheck == false)
                    bCheck = checkYearlySchedule(struct_time->tm_year + 1900, struct_time->tm_yday, struct_time->tm_hour, struct_time->tm_min, struct_time->tm_wday);

                if(bCheck == true) { // update data to be used in startPlaying
                    g_nYear_start_playing = (short)(struct_time->tm_year+1900);
                    g_nMonth_start_playing = (char)struct_time->tm_mon;
                    g_nDay_start_playing = (char)struct_time->tm_mday;
                    g_nHour_start_playing = (char)struct_time->tm_hour;
                    g_nMinute_start_playing = (char)struct_time->tm_min;
#ifdef SAVE_LOG_FILE
                    fprintf(g_file_check, "checkT_play[%s][%d]\n", asctime(struct_time), struct_time->tm_yday);
                    fflush(g_file_check);
//                    printf("checkT_play<%s>[%d]:%d\n", asctime(struct_time), struct_time->tm_yday, bCheck?1:0);
#endif
                    setAudioCommand(true);
                }
            }
            // printf("check stop:%d, %d, %d\n", struct_time->tm_yday, struct_time->tm_hour, struct_time->tm_min);
            if((struct_time->tm_yday == g_nDayOfYear_end)
                    && (struct_time->tm_hour == g_nHour_end)
                    && (struct_time->tm_min == g_nMinute_end)) { // condition to stop playing is met.
#ifdef SAVE_LOG_FILE
                fprintf(g_file_check, "checkT_stop[%s][%d]\n", asctime(struct_time), struct_time->tm_yday);
                fflush(g_file_check);
                //                    printf("checkT_stop<%s>[%d]:%d\n", asctime(struct_time), struct_time->tm_yday, bCheck?1:0);
#endif
                setAudioCommand(false);
            }
        }
        pthread_mutex_unlock(&g_mutex_lock);
#ifdef SAVE_LOG_FILE
        //fprintf(g_file_check, "___threadCheckSchedule<%s>[%d]:%d\n", asctime(struct_time), struct_time->tm_yday, bCheck?1:0);
        //printf("___threadCheckSchedule<%s>[%d]:%d\n", asctime(struct_time), struct_time->tm_yday, bCheck?1:0);
        //fflush(g_file_check);
        //printf("___threadCheckSchedule[%d]:%d\n", struct_time->tm_yday, bCheck?1:0);
#endif
        usleep(1000000);
    }
#ifdef SAVE_LOG_FILE
    fprintf(g_file_info, "----------threadCheckSchedule finished----------\n");
    fflush(g_file_info);
    logFileHandler(3, false);
#endif
}

int main()
{
/*    pid_t pid;

    if((pid = fork()) < 0) {
        printf("Fork Error Exit\n");
        exit(0);
    }else if(pid == 0) { // child process
        setsid();*/
        int sch, act, read;
        pthread_t sch_t, act_t, read_t;
        void* s;

        if(g_file_info == NULL) {
            g_file_info = fopen(INFO_LOG_FILE, "w+");
            if(g_file_info == NULL) {
                printf("log file open error:%s\n", INFO_LOG_FILE);
                exit(EXIT_FAILURE);
            }
        }

        initSignalHandler();
        pthread_mutex_init(&g_mutex_lock, NULL);

        xmlInitParser();

        fprintf(g_file_info, "------------- main program started -----------\n");
        fflush(g_file_info);

        read = pthread_create(&read_t,NULL,threadReadSchedules,NULL);
        sch = pthread_create(&sch_t,NULL,threadCheckSchedule,NULL);
        act = pthread_create(&act_t,NULL,threadPlayMedia,NULL);
        sch = pthread_join(sch_t, &s);
        act = pthread_join(act_t, &s);
        pthread_cancel(read_t);
        read = pthread_join(read_t, &s);

        fprintf(g_file_info, "------------- main program finished -----------\n");
        fflush(g_file_info);

        if(fclose(g_file_info) == 0) {
            g_file_info = NULL;
        }else {
            fprintf(g_file_info, "log file close error:%s\n", INFO_LOG_FILE);
            fflush(g_file_info);
            exit(EXIT_FAILURE);
        }

        //xmlCleanupParser();
        //printf("process is finished\n");
        return 0;
    /*}else { // parent process
        exit(0);
    }*/
}
